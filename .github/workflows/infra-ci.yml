name: 'Deploy Google Cloud Infrastructure'

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
          - staging

  push:
    branches:
      - main
    tags:
      - '*v*'
    paths:
      - 'infra/**'
      - '.github/workflows/infra-ci.yml'
       
permissions:
  contents: write
  id-token: write
  pull-requests: write

# Eliminamos las variables globales de env y solo dejamos una variable que es comÃºn para todos los jobs
env:
  NAMESPACE: dev

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
      - id: set-env
        run: |
          REF="${{ github.ref }}"
          if [[ "$REF" == "refs/heads/main" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          elif [[ "$REF" == refs/tags/staging-v* ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ "$REF" == refs/tags/prod-v* ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT  # Default fallback
          fi


  lint:
    needs: determine-environment
    name: lint
    environment: ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
        terraform_wrapper: false

    - name: Terraform Format
      run: terraform fmt -check -recursive
      continue-on-error: true

    - name: Install TFLint
      run: |
        curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash

    - name: Run TFLint
      run: |
        tflint --recursive --format=compact
      continue-on-error: true

  security:
    needs: determine-environment
    name: security
    environment: ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Install tfsec
      run: |
        curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash

    - name: Run tfsec
      run: |
        tfsec .
      continue-on-error: true

  terraform-fmt:
    needs: [determine-environment, lint, security]
    name: Terraform Format
    environment: ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
        terraform_wrapper: false

    - name: Terraform format
      run: terraform fmt -check -recursive
      continue-on-error: true

    - name: Terraform Init
      run: |
        cd infra/services
        terraform init -backend=false

    - name: Terraform Validate
      run: terraform validate

  gcloud-auth:
    needs: [determine-environment]
    name: Google Auth
    environment: ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    steps:
    - uses: 'actions/checkout@v4'
    - id: 'auth'
      name: 'Authenticate to GCP'
      uses: 'google-github-actions/auth@v2'
      with:
        project_id: ${{ vars.GCP_PROJECT_ID }}
        workload_identity_provider: ${{ vars.WORKLOAD_IDENTITY_PROVIDER }}
        service_account: ${{ vars.SERVICE_ACCOUNT }}
    - id: 'gcloud'
      name: 'gcloud'
      run: |-
        gcloud storage buckets list

  infrastructure:
    needs: [determine-environment, terraform-fmt, gcloud-auth]
    name: Terraform Plan & Apply
    environment: ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infra/services
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
        terraform_wrapper: false

    - name: 'Authenticate to GCP'
      uses: 'google-github-actions/auth@v2'
      with:
        project_id: ${{ vars.GCP_PROJECT_ID }}
        workload_identity_provider: ${{ vars.WORKLOAD_IDENTITY_PROVIDER }}
        service_account: ${{ vars.SERVICE_ACCOUNT }}

    - name: Terraform Init
      id: init
      run: |
        terraform init \
          -backend-config="bucket=${{ vars.BACKEND_STORAGE_ACCOUNT }}" \
          -backend-config="prefix=terraform/state/${{ needs.determine-environment.outputs.environment }}"

    - name: Ensure tfvars file exists
      run: |
        if [ ! -f "../envs/${{ needs.determine-environment.outputs.environment }}.tfvars" ]; then
          echo "tfvars file not found for environment: ${{ needs.determine-environment.outputs.environment }}"
          exit 1
        fi

    - name: Terraform Plan
      run: |
        terraform plan -lock=false \
          -out='${{ needs.determine-environment.outputs.environment }}.plan.tfplan' \
          -var-file="../envs/${{ needs.determine-environment.outputs.environment }}.tfvars" \
          -var="region=${{ vars.GCP_REGION }}" \
          -var="project_id=${{ vars.GCP_PROJECT_ID }}" \
          -var="network_option=${{ vars.NETWORKING_OPTION || 'create_new' }}" \
          -var="existing_vpc_name=${{ vars.VPC_NAME || '' }}" \
          -var="existing_subnet_name=${{ vars.SUBNET_NAME || '' }}" \
          -var="storage_location=${{ vars.GCP_REGION }}" \
          -var="environment=${{ needs.determine-environment.outputs.environment }}" \
          -var="unique_suffix=${{ vars.UNIQUE_SUFFIX || 'gcp101' }}"
      continue-on-error: true

    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: infra/services/${{ needs.determine-environment.outputs.environment }}.plan.tfplan
        retention-days: 5

    - name: Terraform Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1

    - name: Terraform Apply
      run: |
        terraform apply -auto-approve -input=false ${{ needs.determine-environment.outputs.environment }}.plan.tfplan


    - name: Capture Terraform Outputs
      if: success()
      run: |
        CURRENT_ENV="${{ needs.determine-environment.outputs.environment }}"

        # Project info
        gh variable set PROJECT_NUMBER --env $CURRENT_ENV --body "$(terraform output -raw project_number)"

        # Artifact repository
        gh variable set ARTIFACT_REPOSITORY_URL --env $CURRENT_ENV --body "$(terraform output -raw repository_url)"
        gh variable set Docker_IMAGE_PATH --env $CURRENT_ENV --body "$(terraform output -raw docker_image_path)"
        gh variable set ARTIFACT_REGISTRY_ID --env $CURRENT_ENV --body "$(terraform output -raw repository_id)"

        #Cloud armor 
        gh variable set CLOUD_ARMOR_POLICY_NAME --env $CURRENT_ENV --body "$(terraform output -raw security_policy_name)"
        
        # Storage buckets
        gh variable set APP_DATA_BUCKET --env $CURRENT_ENV --body "$(terraform output -json bucket_names | jq -r '.[0]')"
        gh variable set APP_MEDIA_BUCKET --env $CURRENT_ENV --body "$(terraform output -json bucket_names | jq -r '.[1]')"
        gh variable set VERTEX_AI_DATA_BUCKET --env $CURRENT_ENV --body "$(terraform output -json bucket_names | jq -r '.[2]')"
        
        # External Estatic Ip address
        gh variable set FRONT_IP_ADDRESS --env $CURRENT_ENV --body "$(terraform output -raw gke_frontend_ip)"
        gh variable set API_IP_ADDRESS --env $CURRENT_ENV --body "$(terraform output -raw gke_api_ip)"
        gh variable set FRONT_IP_NAME --env $CURRENT_ENV --body "$(terraform output -raw gke_frontend_ip_name)"
        gh variable set API_IP_NAME --env $CURRENT_ENV --body "$(terraform output -raw gke_api_ip_name)"

        # Database info
        gh variable set DB_CONNECTION_NAME --env $CURRENT_ENV --body "$(terraform output -raw db_connection_name)"
        gh variable set DB_INSTANCE_NAME --env $CURRENT_ENV --body "$(terraform output -raw db_instance_name)"
        gh variable set DB_DATABASE_NAME --env $CURRENT_ENV --body "$(terraform output -raw db_database_name)"
        gh variable set DB_USER_NAME --env $CURRENT_ENV --body "$(terraform output -raw db_user_name)"
        
        # Firestore
        gh variable set FIRESTORE_DATABASE --env $CURRENT_ENV --body "$(terraform output -raw firestore_database)"
        gh variable set FIRESTORE_COLLECTIONS --env $CURRENT_ENV --body "$(terraform output -json firestore_collections)"
        
        # Vertex AI endpoints
        gh variable set VERTEX_AI_ENDPOINT_ID --env $CURRENT_ENV --body "$(terraform output -raw vertex_ai_endpoint_id)"
        gh variable set VERTEX_AI_INDEX_ENDPOINT_ID --env $CURRENT_ENV --body "$(terraform output -raw vertex_ai_index_endpoint_id)"
        gh variable set VERTEX_AI_INDEX_ID --env $CURRENT_ENV --body "$(terraform output -raw vertex_ai_index_id)"
        
        # GKE info
        gh variable set kubectl_command --env $CURRENT_ENV --body "$(terraform output -raw gke_kubectl_command)"
        gh variable set GKE_CLUSTER_NAME --env $CURRENT_ENV --body "$(terraform output -raw gke_cluster_name)"
        gh variable set GKE_CLUSTER_ENDPOINT --env $CURRENT_ENV --body "$(terraform output -raw gke_cluster_endpoint)"
      
        # Network info
        gh variable set NETWORK_NAME --env $CURRENT_ENV --body "$(terraform output -raw network_name)"
        
        # Document AI (Processors)
        gh variable set FORM_PARSER_ENDPOINT --env $CURRENT_ENV --body "$(terraform output -json processor_endpoints | jq -r '."form-parser"')"
        gh variable set INVOICE_PROCESSOR_ENDPOINT --env $CURRENT_ENV --body "$(terraform output -json processor_endpoints | jq -r '."invoice-processor"')"
        gh variable set OCR_PROCESSOR_ENDPOINT --env $CURRENT_ENV --body "$(terraform output -json processor_endpoints | jq -r '."ocr-processor"')"
        
        # Service accounts
        gh variable set GSA_PODS_SERVICE_ACCOUNT --env $CURRENT_ENV --body "$(terraform output -raw pods_service_account_email)"
      env:
        GITHUB_TOKEN: ${{ secrets.GHACTIONS_TOKEN }}

    - name: Set up Cloud SDK with GKE plugin
      uses: google-github-actions/setup-gcloud@v2
      with:
        install_components: 'gke-gcloud-auth-plugin'

    - name: Get GKE Credentials
      run: |
          gcloud container clusters get-credentials $(terraform output -raw gke_cluster_name) \
            --dns-endpoint \
            --region=${{ vars.GCP_REGION }} \
            --project=${{ vars.GCP_PROJECT_ID }}

    - name: Create Kubernetes Namespace
      run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
    - name: Create Kubernetes Service Account for Pods
      run: |
        kubectl create serviceaccount pods-sa -n ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
    - name: Create Kubernetes Service Account for ESPV2
      run: |
        kubectl create serviceaccount espv2-sa -n ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
    - name: Annotate Pods Service Account for Workload Identity
      run: |
        kubectl annotate serviceaccount pods-sa -n ${{ env.NAMESPACE }} \
        iam.gke.io/gcp-service-account=$(terraform output -raw pods_service_account_email) --overwrite
      
    - name: Annotate ESPV2 Service Account for Workload Identity
      run: |
        kubectl annotate serviceaccount espv2-sa -n ${{ env.NAMESPACE }} \
        iam.gke.io/gcp-service-account=$(terraform output -raw espv2_service_account_email) --overwrite
      
    - name: Bind Kubernetes Pods Service Account to IAM Role
      run: |
        gcloud iam service-accounts add-iam-policy-binding $(terraform output -raw pods_service_account_email) \
        --role roles/iam.workloadIdentityUser \
        --member "serviceAccount:${{ vars.GCP_PROJECT_ID }}.svc.id.goog[${{ env.NAMESPACE }}/pods-sa]"
      
    - name: Bind Kubernetes ESPV2 Service Account to IAM Role
      run: |
        gcloud iam service-accounts add-iam-policy-binding $(terraform output -raw espv2_service_account_email) \
        --role roles/iam.workloadIdentityUser \
        --member "serviceAccount:${{ vars.GCP_PROJECT_ID }}.svc.id.goog[${{ env.NAMESPACE }}/espv2-sa]"

  cloud-endpoint:
    needs: [infrastructure, determine-environment]
    name: Configure API Gateway
    environment: ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          project_id: ${{ vars.GCP_PROJECT_ID }}
          workload_identity_provider: ${{ vars.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.SERVICE_ACCOUNT }}

      - name: Setup gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ vars.GCP_PROJECT_ID }}
          
      - name: Set ENDPOINT_HOST
        run: |
          echo "ENDPOINT_HOST=demoapi.endpoints.${{ vars.GCP_PROJECT_ID }}.cloud.goog" >> $GITHUB_ENV
  
      - name: Install envsubst
        run: sudo apt-get update && sudo apt-get install -y gettext-base
  
      - name: Generate OpenAPI spec
        run: |
          envsubst '${ENDPOINT_HOST}' \
            < app/backend/openapi.tpl.yaml \
            > app/backend/openapi.yaml
  
      - name: Install swagger-cli
        run: npm install -g @apidevtools/swagger-cli
    
      - name: Validate OpenAPI spec
        run: swagger-cli validate app/backend/openapi.yaml
  
      - name: Deploy to Cloud Endpoints
        run: |
          gcloud endpoints services deploy \
          app/backend/openapi.yaml \
          --project ${{ vars.GCP_PROJECT_ID }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
  
      - name: Create or reuse API Key
        id: create_api_key
        run: |
          # Exit immediately if a command exits with a non-zero status.
          set -e

          NAME="Endpoints API Key for ${{ vars.GCP_PROJECT_ID }}"
          FILTER_EXPRESSION="displayName=\"${NAME}\"" 

          echo "â Looking for API Key with display name: ${NAME}"
          KEY_NAME=$(gcloud services api-keys list \
            --project="${{ vars.GCP_PROJECT_ID }}" \
            --filter="${FILTER_EXPRESSION}" \
            --format="value(name)" \
            --limit=1) # Limit to 1 just in case of duplicates somehow

          if [[ -z "$KEY_NAME" ]]; then
            echo "â API Key not found. Creating new API Key..."

            # Create the key
            gcloud services api-keys create \
              --project="${{ vars.GCP_PROJECT_ID }}" \
              --display-name="${NAME}" \
              --quiet

            echo "â Fetching name of newly created API Key..."
            KEY_NAME=$(gcloud services api-keys list \
              --project="${{ vars.GCP_PROJECT_ID }}" \
              --filter="${FILTER_EXPRESSION}" \
              --format="value(name)" \
              --limit=1) # Re-fetch the name

            # Add a check in case fetching failed after creation
            if [[ -z "$KEY_NAME" ]]; then
              echo "ERROR: Failed to retrieve the key name after creation."
              exit 1
            fi
             echo "â Successfully created and retrieved API Key name: ${KEY_NAME##*/}"
            # ----------------------------------------------------

          else
            echo "â Reusing existing API Key: ${KEY_NAME##*/}"
          fi

          echo "â Fetching Key String for ${KEY_NAME##*/}"
          KEY_STRING=$(gcloud services api-keys get-key-string "${KEY_NAME}" \
            --project="${{ vars.GCP_PROJECT_ID }}" \
            --format="value(keyString)") 

          if [[ -z "$KEY_STRING" ]]; then
             echo "ERROR: Failed to retrieve the key string for key ${KEY_NAME}."
             exit 1
          fi

          echo "â Applying restrictions to ${KEY_NAME##*/}"
          gcloud services api-keys update "${KEY_NAME}" \
            --project="${{ vars.GCP_PROJECT_ID }}" \
            --api-target=service=demoapi.endpoints.${{ vars.GCP_PROJECT_ID }}.cloud.goog
            
          echo "â API Key setup complete."

          # Add the key string to GitHub environment variables and mask it
          echo "ENDPOINTS_API_KEY=${KEY_STRING}" >> $GITHUB_ENV
          echo "::add-mask::${KEY_STRING}"

      - name: Save ENDPOINT API Key to GitHub Secrets
        run: |
          echo "$ENDPOINTS_API_KEY" | gh secret set ENDPOINTS_API_KEY --env "${{ needs.determine-environment.outputs.environment }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GHACTIONS_TOKEN }}